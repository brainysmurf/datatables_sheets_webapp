
<div id="wrapper">
    <div id="row">
        <div id="document">
            <div>hi</div>
        </div>

        <div id="sidebar">
            <div class="sidebarTitlebar">Gamified Journal</div>
            <div id="bodyContent"></div>
        </div>
    </div>
</div>

<script>

$(function () {
    // document ready, create the document on the right-hand side
    // sure beats relying on a production variable...
    console.log($('#document'));
});

(function (window) {
    var googleRunScript = {
        successHandlers: [],
        failureHandlers: [],
        userObject: {},
        withSuccessHandler: function(func) {
            this.successHandlers.push(func);
            return this;
        },
        withFailureHandler: function(func) {
            this.failureHandlers.push(func);
            return this;
        },
        withUserObject: function(obj) {
            this.userObject = obj;
            return this;
        },
    };

    var getter = {

        clientSideMocks: {
            start: function () { 
                console.log('start');
            },
            finish: function () {
                console.log('finish');
            },
            notify: function () {
                console.log("notify");
            },
        },

        /*
            Get function allows us to add a __noSuchMethod__ feature onto
            googleRunScript above

            Limitations, because we are returning a promise, we cannot call it
        */
        get: function(target, name) {

            // If already defined, i.e. with.. method, use that...
            if (name in target) {
                return target[name];

            // otherwise this is something that needs to be emulated...
            } else {
                // just returning clientSideMocks[name] will not allow us to call handlers
                // so let's return a promise

                var promise = new Promise(
                    function (resolve, reject) {
                        try {
                            var result = this.clientSideMocks[name](/* the arg would go here */);
                            resolve(result);
                        } catch(err) {
                            reject(err)
                        }
                    }.bind(this)
                );
                promise.then(
                    function (args) {
                        target.successHandlers.forEach(function (func) {
                            // call the success handlers
                            func(args, target.userObject);
                        });
                    }
                ).catch(
                    function (args) {
                        target.failureHandlers.forEach(function (func) {
                            func(args, target.userObject);
                        });
                    }
                );

                // Need to wrap in a function in order for it to be called
                // This means we canNOT use argument to call anything...
                return function () { promise };
            }

        }
    };

    window.google = {
        script: {
            run: new Proxy(googleRunScript, getter),
            host: {
                close: function() { window.close(); },
                origin: '',
                editor: {
                    focus: function () { /* TBI */; },
                },
                setHeight: function (height) { /* TBI */; },
                setWidth: function (width) { /* TBI */; },
            }
        },
    }
})(window);

</script>